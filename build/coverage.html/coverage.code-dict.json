{"/home/travis/build/npmtest/node-npmtest-web-audio-api/test.js":"/* istanbul instrument in package npmtest_web_audio_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/lib.npmtest_web_audio_api.js":"/* istanbul instrument in package npmtest_web_audio_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_web_audio_api = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_web_audio_api = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-web-audio-api && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_web_audio_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_web_audio_api\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_web_audio_api.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_web_audio_api.rollup.js'] =\n            local.assetsDict['/assets.npmtest_web_audio_api.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_web_audio_api.__dirname + '/lib.npmtest_web_audio_api.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/index.js":"module.exports = {\n\n  AudioContext: require('./build/AudioContext'),\n  AudioParam: require('./build/AudioParam'),\n  AudioNode: require('./build/AudioNode'),\n  AudioDestinationNode: require('./build/AudioDestinationNode'),\n  AudioBuffer: require('./build/AudioBuffer'),\n  AudioBufferSourceNode: require('./build/AudioBufferSourceNode'),\n  GainNode: require('./build/GainNode'),\n\n  constants: require('./build/constants')\n\n}\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/AudioContext.js":"var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;var _ = require('underscore')\n  , events = require('events')\n  , async = require('async')\n  , pcmUtils = require('pcm-boilerplate')\n  , utils = require('./utils')\n  , constants = require('./constants')\n  , BLOCK_SIZE = constants.BLOCK_SIZE\n  , AudioBuffer = require('./AudioBuffer')\n  , AudioDestinationNode = require('./AudioDestinationNode')\n  , AudioBufferSourceNode = require('./AudioBufferSourceNode')\n  , GainNode = require('./GainNode')\n  , ScriptProcessorNode = require('./ScriptProcessorNode')\n\n\nvar AudioContext = (function(super$0){\"use strict\";super$0=events.EventEmitter;if(!PRS$0)MIXIN$0(AudioContext, super$0);var proto$0={};\n\n  function AudioContext(opts) {var this$0 = this;\n    var outBuff\n\n    /*Object.defineProperty(this, 'currentTime', {\n    writable: false,\n    get: function() {}\n  })*/\n\n    Object.defineProperty(this, 'destination', {\n      writable: false,\n      value: new AudioDestinationNode(this)\n    })\n    //this.destination = new AudioDestinationNode(this)\n\n    /*Object.defineProperty(this, 'sampleRate', {\n    writable: false,\n    value: {} // TODO\n  })\n\n  Object.defineProperty(this, 'listener', {\n    writable: false,\n    value: {} // TODO\n  })*/\n    this.currentTime = 0\n    this.sampleRate = 44100\n    this.numberOfChannels = 2\n    this.bitDepth = 16\n\n    this.format = {\n      numberOfChannels: 2,\n      bitDepth: 16,\n      sampleRate: this.sampleRate\n    }\n\n    opts = opts || {}\n    if (opts.bufferSize) this.format.bufferSize = opts.bufferSize\n    if (opts.numBuffers) this.format.numBuffers = opts.numBuffers\n\n    this.outStream = null\n    this._encoder = pcmUtils.BufferEncoder(this.format)\n    this._frame = 0\n    this._playing = true\n    this._audioOutLoopRunning = false\n\n    // When a new connection is established, start to pull audio\n    this.destination._inputs[0].on('connection', function()  {\n      if (this$0._audioOutLoopRunning) return\n      if (!this$0.outStream) throw new Error('you need to set outStream to send the audio somewhere')\n      this$0._audioOutLoopRunning = true\n      async.whilst(\n        function()  {\n          return this$0._playing\n        },\n        function(next)  {\n          outBuff = this$0.destination._tick()\n          // If there is space in the output stream's buffers, we write,\n          // otherwise we wait for 'drain'\n          this$0._frame += BLOCK_SIZE\n          this$0.currentTime = this$0._frame * 1 / this$0.sampleRate\n          // TODO setImmediate here is for cases where the outStream won't get\n          // full and we end up with call stack max size reached.\n          // But is it optimal?\n          if (this$0.outStream.write(this$0._encoder(outBuff._data)))\n            setImmediate(next)\n          else this$0.outStream.once('drain', next)\n        },\n        function(err)  {\n          this$0._audioOutLoopRunning = false\n          if (err) return this$0.emit('error', err)\n        }\n      )\n    })\n  }if(super$0!==null)SP$0(AudioContext,super$0);AudioContext.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":AudioContext,\"configurable\":true,\"writable\":true}});DP$0(AudioContext,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0.createBuffer = function(numberOfChannels, length, sampleRate) {\n    return new AudioBuffer(numberOfChannels, length, sampleRate)\n  };\n\n  proto$0.decodeAudioData = function(audioData, successCallback, errorCallback) {\n    utils.decodeAudioData(audioData, function(err, audioBuffer) {\n      if (err) errorCallback(err)\n      else successCallback(audioBuffer)\n    })\n  };\n\n  proto$0.createBufferSource = function() {\n    return new AudioBufferSourceNode(this)\n  };\n\n  proto$0.createGain = function() {\n    return new GainNode(this)\n  };\n\n  proto$0.createScriptProcessor = function(bufferSize, numberOfInputChannels, numberOfOutputChannels) {\n    return new ScriptProcessorNode(this, bufferSize, numberOfInputChannels, numberOfOutputChannels)\n  };\n\n  /*\n{\n\n    readonly attribute AudioDestinationNode destination\n    readonly attribute float sampleRate\n    readonly attribute double currentTime\n    readonly attribute AudioListener listener\n\n    // AudioNode creation\n    MediaElementAudioSourceNode createMediaElementSource(HTMLMediaElement mediaElement)\n\n    MediaStreamAudioSourceNode createMediaStreamSource(MediaStream mediaStream)\n    MediaStreamAudioDestinationNode createMediaStreamDestination()\n\n    AnalyserNode createAnalyser()\n    DelayNode createDelay(optional double maxDelayTime = 1.0)\n    BiquadFilterNode createBiquadFilter()\n    WaveShaperNode createWaveShaper()\n    PannerNode createPanner()\n    ConvolverNode createConvolver()\n\n    ChannelSplitterNode createChannelSplitter(optional unsigned long numberOfOutputs = 6)\n    ChannelMergerNode createChannelMerger(optional unsigned long numberOfInputs = 6)\n\n    DynamicsCompressorNode createDynamicsCompressor()\n\n    OscillatorNode createOscillator()\n    PeriodicWave createPeriodicWave(Float32Array real, Float32Array imag)\n\n}\n  */\n\n  proto$0._kill = function() {\n    this._playing = false\n    if (this.outStream) {\n      if (this.outStream.close) {\n        this.outStream.close()\n      } else {\n        this.outStream.end()\n      }\n    }\n  };\n\n  proto$0.collectNodes = function(node, allNodes) {var this$0 = this;\n    allNodes = allNodes || []\n    node = node || this.destination\n    _.chain(node._inputs)\n      .pluck('sources')\n      .reduce(function(all, sources) {\n        return all.concat(sources)\n      }, [])\n      .pluck('node').value()\n      .forEach(function(upstreamNode)  {\n        if (!_.contains(allNodes, upstreamNode)) {\n          allNodes.push(upstreamNode)\n          this$0.collectNodes(upstreamNode, allNodes)\n        }\n      })\n    return allNodes\n  };\n\nMIXIN$0(AudioContext.prototype,proto$0);proto$0=void 0;return AudioContext;})();\n\nmodule.exports = AudioContext\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/utils.js":"var AudioBuffer = require('./AudioBuffer')\n  , AV = require('av')\n  , mp3 = require('mp3')\n  , flac = require('flac')\n  , alac = require('alac')\n  , aac = require('aac')\n\n\n// Simple helper to make defining a read-only attribute less verbose\nmodule.exports.readOnlyAttr = function(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    value: value,\n    writable: false\n  })\n}\n\n// Helper to decode a buffer of encoded audio data.\n// Guesses the format, and decodes to an AudioBuffer accordingly.\nmodule.exports.decodeAudioData = function(buffer, done) {\n  var asset = AV.Asset.fromBuffer(buffer)\n\n  asset.on('error', function(err) {\n    done(err)\n  })\n\n  asset.decodeToBuffer(function(decoded) {\n    var deinterleaved = []\n      , numberOfChannels = asset.format.channelsPerFrame\n      , length = Math.floor(decoded.length / numberOfChannels)\n      , ch, chArray, i\n\n    for (ch = 0; ch < numberOfChannels; ch++)\n      deinterleaved.push(new Float32Array(length))\n\n    for (ch = 0; ch < numberOfChannels; ch++) {\n      chArray = deinterleaved[ch]\n      for (i = 0; i < length; i++)\n        chArray[i] = decoded[ch + i * numberOfChannels]\n    }\n\n    done(null, AudioBuffer.fromArray(deinterleaved, asset.format.sampleRate))\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/AudioBuffer.js":"var _ = require('underscore')\n\nvar AudioBuffer = (function(){\"use strict\";var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var static$0={},proto$0={};\n\n  function AudioBuffer(numberOfChannels, length, sampleRate) {\n    var ch\n    this._data = []\n    // Just a hack to be able to create a partially initialized AudioBuffer\n    if (arguments.length) {\n      for (ch = 0; ch < numberOfChannels; ch++)\n        this._data.push(new Float32Array(length))\n      this._defineAttrs(numberOfChannels, length, sampleRate)\n    }\n  }DP$0(AudioBuffer,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0.getChannelData = function(channel) {\n    if (channel >= this.numberOfChannels) throw new Error('invalid channel')\n    return this._data[channel]\n  };\n\n  proto$0.slice = function() {\n    var sliceArgs = _.toArray(arguments)\n    var array = this._data.map(function(chArray) {\n        return chArray.subarray.apply(chArray, sliceArgs)\n      })\n    return AudioBuffer.fromArray(array, this.sampleRate)\n  };\n\n  proto$0.concat = function(other) {\n    if (other.sampleRate !== this.sampleRate)\n      throw new Error('the 2 AudioBuffers don\\'t have the same sampleRate')\n    if (other.numberOfChannels !== this.numberOfChannels)\n      throw new Error('the 2 AudioBuffers don\\'t have the same numberOfChannels')\n    var newLength = other.length + this.length,\n      newChArray, newArray = this._data.map(function(chArray, ch) {\n        newChArray = new Float32Array(newLength)\n        newChArray.set(chArray)\n        newChArray.set(other._data[ch], chArray.length)\n        return newChArray\n      })\n    return AudioBuffer.fromArray(newArray, this.sampleRate)\n  };\n\n  proto$0.set = function(other, offset) {\n    if (other.sampleRate !== this.sampleRate)\n      throw new Error('the 2 AudioBuffers don\\'t have the same sampleRate')\n    if (other.numberOfChannels !== this.numberOfChannels)\n      throw new Error('the 2 AudioBuffers don\\'t have the same numberOfChannels')\n    this._data.forEach(function(chArray, ch) {\n      chArray.set(other.getChannelData(ch), offset)\n    })\n  };\n\n  proto$0._defineAttrs = function(numberOfChannels, length, sampleRate) {\n    if (!(sampleRate > 0)) throw new Error('invalid sample rate : ' + sampleRate)\n    Object.defineProperty(this, 'sampleRate', {\n      value: sampleRate,\n      writable: false\n    })\n    if (!(length >= 0)) throw new Error('invalid length : ' + length)\n    Object.defineProperty(this, 'length', {\n      value: length,\n      writable: false\n    })\n    Object.defineProperty(this, 'duration', {\n      value: length / sampleRate,\n      writable: false\n    })\n    if (!(numberOfChannels > 0)) throw new Error('invalid numberOfChannels : ' + numberOfChannels)\n    Object.defineProperty(this, 'numberOfChannels', {\n      value: numberOfChannels,\n      writable: false\n    })\n  };\n\n  static$0.filledWithVal = function(val, numberOfChannels, length, sampleRate) {\n    var audioBuffer = new AudioBuffer(numberOfChannels, length, sampleRate),\n      chData, ch, i\n    for (ch = 0; ch < numberOfChannels; ch++) {\n      chData = audioBuffer._data[ch]\n      for (i = 0; i < length; i++) chData[i] = val\n    }\n    return audioBuffer\n  };\n\n  static$0.fromArray = function(array, sampleRate) {\n    var audioBuffer = new AudioBuffer()\n    audioBuffer._defineAttrs(array.length, array[0].length, sampleRate)\n    array.forEach(function(chArray) {\n      if (!(chArray instanceof Float32Array))\n        chArray = new Float32Array(chArray)\n      audioBuffer._data.push(chArray)\n    })\n    return audioBuffer\n  };\n\nMIXIN$0(AudioBuffer,static$0);MIXIN$0(AudioBuffer.prototype,proto$0);static$0=proto$0=void 0;return AudioBuffer;})();\n\nmodule.exports = AudioBuffer\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/constants.js":"module.exports.BLOCK_SIZE = 128","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/AudioDestinationNode.js":"var AudioNode = require('./AudioNode')\n  , readOnlyAttr = require('./utils').readOnlyAttr\n\n\nvar AudioDestinationNode = (function(super$0){\"use strict\";var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;if(!PRS$0)MIXIN$0(AudioDestinationNode, super$0);var proto$0={};\n\n  function AudioDestinationNode(context) {\n    super$0.call(this, context, 1, 0, 2, 'explicit', 'speakers')\n\n    readOnlyAttr(this, 'maxChannelCount', 2)\n  }if(super$0!==null)SP$0(AudioDestinationNode,super$0);AudioDestinationNode.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":AudioDestinationNode,\"configurable\":true,\"writable\":true}});DP$0(AudioDestinationNode,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  // This only pulls the data from the nodes upstream\n  proto$0._tick = function() {\n    return this._inputs[0]._tick()\n  };\n\nMIXIN$0(AudioDestinationNode.prototype,proto$0);proto$0=void 0;return AudioDestinationNode;})(AudioNode);\n\n\nmodule.exports = AudioDestinationNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/AudioNode.js":"var EventEmitter = require('events').EventEmitter\n  , async = require('async')\n  , utils = require('./utils')\n  , readOnlyAttr = utils.readOnlyAttr\n  , DspObject = require('./DspObject')\n  , AudioInput = require('./audioports').AudioInput\n  , AudioOutput = require('./audioports').AudioOutput\n\nvar ChannelCountMode = ['max', 'clamped-max', 'explicit'],\n  ChannelInterpretation = ['speakers', 'discrete']\n\nvar AudioNode = (function(super$0){\"use strict\";var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;if(!PRS$0)MIXIN$0(AudioNode, super$0);var proto$0={};\n\n  function AudioNode(context, numberOfInputs, numberOfOutputs, channelCount, channelCountMode, channelInterpretation) {\n\n    super$0.call(this, context)\n\n    readOnlyAttr(this, 'context', context)\n    readOnlyAttr(this, 'numberOfInputs', numberOfInputs)\n    readOnlyAttr(this, 'numberOfOutputs', numberOfOutputs)\n\n    channelCount = channelCount || 2\n    Object.defineProperty(this, 'channelCount', {\n      get: function() {\n        return channelCount\n      },\n      set: function(val) {\n        if (val < 1) throw new Error('Invalid number of channels')\n        channelCount = val\n      },\n      configurable: true\n    })\n\n    var channelCountMode = channelCountMode\n    Object.defineProperty(this, 'channelCountMode', {\n      get: function() {\n        return channelCountMode\n      },\n      set: function(val) {\n        if (ChannelCountMode.indexOf(val) === -1)\n          throw new Error('Unvalid value for channelCountMode : ' + val)\n        channelCountMode = val\n      },\n      configurable: true\n    })\n\n    var channelInterpretation = channelInterpretation\n    Object.defineProperty(this, 'channelInterpretation', {\n      get: function() {\n        return channelInterpretation\n      },\n      set: function(val) {\n        if (ChannelInterpretation.indexOf(val) === -1)\n          throw new Error('Unvalid value for channelInterpretation : ' + val)\n        channelInterpretation = val\n      },\n      configurable: true\n    })\n\n    // Initialize audio ports\n    var i\n    this._inputs = []\n    this._outputs = []\n    for (i = 0; i < this.numberOfInputs; i++)\n      this._inputs.push(new AudioInput(context, this, i))\n    for (i = 0; i < this.numberOfOutputs; i++)\n      this._outputs.push(new AudioOutput(context, this, i))\n\n  }if(super$0!==null)SP$0(AudioNode,super$0);AudioNode.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":AudioNode,\"configurable\":true,\"writable\":true}});DP$0(AudioNode,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0.connect = function(destination) {var output = arguments[1];if(output === void 0)output = 0;var input = arguments[2];if(input === void 0)input = 0;\n    if (output >= this.numberOfOutputs)\n      throw new Error('output out of bounds ' + output)\n    if (input >= destination.numberOfInputs)\n      throw new Error('input out of bounds ' + input)\n    this._outputs[output].connect(destination._inputs[input])\n  };\n\n  proto$0.disconnect = function() {var output = arguments[0];if(output === void 0)output = 0;\n    if (output >= this.numberOfOutputs)\n      throw new Error('output out of bounds ' + output)\n    var audioOut = this._outputs[output]\n    audioOut.sinks.slice(0).forEach(function(sink) {\n      audioOut.disconnect(sink)\n    })\n  };\n\n  // Disconnects all ports and remove all events listeners\n  proto$0._kill = function() {\n    this._inputs.forEach(function(input) {\n      input._kill()\n    })\n    this._outputs.forEach(function(output) {\n      output._kill()\n    })\n    this.removeAllListeners()\n    this._tick = function() {\n      throw new Error('this node has been killed')\n    }\n  };\n\nMIXIN$0(AudioNode.prototype,proto$0);proto$0=void 0;return AudioNode;})(DspObject);\n\nmodule.exports = AudioNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/DspObject.js":"var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;var _ = require('underscore')\n  , events = require('events')\n\nvar DspObject = (function(super$0){\"use strict\";super$0=events.EventEmitter;if(!PRS$0)MIXIN$0(DspObject, super$0);var proto$0={};\n\n  function DspObject(context) {\n    super$0.call(this)\n    this.context = context\n    this._scheduled = []\n  }if(super$0!==null)SP$0(DspObject,super$0);DspObject.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":DspObject,\"configurable\":true,\"writable\":true}});DP$0(DspObject,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0._tick = function() {\n    this._frame++\n    var event = this._scheduled.shift()\n      , eventsSameTime, eventsToExecute = []\n      , previousTime\n    \n    // Gather all events that need to be executed at this tick\n    while (event && event.time <= this.context.currentTime) {\n      previousTime = event.time\n      eventsSameTime = []\n      // Gather all the events with same time\n      while (event && event.time === previousTime) {\n        // Add the event only if there isn't already events with same type\n        if (eventsSameTime.every(function(other) {\n          return event.type !== other.type\n        })) eventsSameTime.push(event)\n        event = this._scheduled.shift()\n      }\n      eventsSameTime.forEach(function(event) {\n        eventsToExecute.push(event)\n      })\n    }\n    if (event) this._scheduled.unshift(event)\n    \n    // And execute\n    eventsToExecute.reverse().forEach(function(event) {\n      event.func && event.func()\n    })\n  };\n\n  proto$0._schedule = function(type, time, func, args) {\n    var event = {\n        time: time,\n        func: func,\n        type: type\n      },\n      ind = _.sortedIndex(this._scheduled, event, function(e) {\n        return e.time\n      })\n    if (args) event.args = args\n    this._scheduled.splice(ind, 0, event)\n  };\n\n  proto$0._unscheduleTypes = function(types) {\n    this._scheduled = _.reject(this._scheduled, function(event) {\n      return _.contains(types, event.type)\n    })\n  };\n\nMIXIN$0(DspObject.prototype,proto$0);proto$0=void 0;return DspObject;})();\n\nmodule.exports = DspObject\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/audioports.js":"var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;var _ = require('underscore')\n  , async = require('async')\n  , events = require('events')\n  , utils = require('./utils')\n  , AudioBuffer = require('./AudioBuffer')\n  , BLOCK_SIZE = require('./constants').BLOCK_SIZE\n  , ChannelMixing = require('./ChannelMixing')\n\n\nvar AudioPort = (function(super$0){\"use strict\";super$0=events.EventEmitter;if(!PRS$0)MIXIN$0(AudioPort, super$0);var proto$0={};\n\n  function AudioPort(context, node, id) {\n    super$0.call(this)\n    this.connections = []\n    this.node = node\n    this.id = id\n    this.context = context\n  }if(super$0!==null)SP$0(AudioPort,super$0);AudioPort.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":AudioPort,\"configurable\":true,\"writable\":true}});DP$0(AudioPort,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  // Generic function for connecting the calling AudioPort\n  // with `otherPort`. Returns true if a connection was indeed established\n  proto$0.connect = function(otherPort) {\n    if (this.connections.indexOf(otherPort) !== -1) return false\n    this.connections.push(otherPort)\n    otherPort.connect(this)\n    this.emit('connection', otherPort)\n    return true\n  };\n\n  // Generic function for disconnecting the calling AudioPort\n  // from `otherPort`. Returns true if a disconnection was indeed made\n  proto$0.disconnect = function(otherPort) {\n    var connInd = this.connections.indexOf(otherPort)\n    if (connInd === -1) return false\n    this.connections.splice(connInd, 1)\n    otherPort.disconnect(this)\n    this.emit('disconnection', otherPort)\n    return true\n  };\n\n  // Called when a node is killed. Removes connections, and event listeners.\n  proto$0._kill = function() {var this$0 = this;\n    this.connections.slice(0).forEach(function(port)  {\n      this$0.disconnect(port)\n    })\n    this.removeAllListeners()\n  };\n\nMIXIN$0(AudioPort.prototype,proto$0);proto$0=void 0;return AudioPort;})();\n\nvar AudioInput = (function(super$0){\"use strict\";if(!PRS$0)MIXIN$0(AudioInput, super$0);var proto$0={};\n\n  function AudioInput(context, node, id) {var this$0 = this;\n    super$0.call(this, context, node, id)\n\n    // `computedNumberOfChannels` is scheduled to be recalculated everytime a connection\n    // or disconnection happens.\n    this.computedNumberOfChannels = null\n    this.on('connected', function()  {\n      this$0.computedNumberOfChannels = null\n    })\n    this.on('disconnected', function()  {\n      this$0.computedNumberOfChannels = null\n    })\n\n    // Just for code clarity\n    Object.defineProperty(this, 'sources', {\n      get: function() {\n        return this.connections\n      }\n    })\n  }if(super$0!==null)SP$0(AudioInput,super$0);AudioInput.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":AudioInput,\"configurable\":true,\"writable\":true}});DP$0(AudioInput,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0.connect = function(source) {var this$0 = this;\n    // When the number of channels of the source changes, we trigger\n    // computation of `computedNumberOfChannels`\n    source.on('_numberOfChannels', function()  {\n      this$0.computedNumberOfChannels = null\n    })\n    //AudioPort.prototype.connect.call(this, source)\n    super$0.prototype.connect.call(this, source)\n  };\n\n  proto$0.disconnect = function(source) {\n    source.removeAllListeners('_numberOfChannels')\n    //AudioPort.prototype.disconnect.call(this, source)\n    super$0.prototype.disconnect.call(this, source)\n  };\n\n  proto$0._tick = function() {var this$0 = this;\n    var i, ch, inNumChannels, inBuffers = this.sources.map(function(source) {\n      return source._tick()\n    })\n\n    if (this.computedNumberOfChannels === null) {\n      var maxChannelsUpstream\n      if (this.sources.length) {\n        maxChannelsUpstream = _.chain(inBuffers).pluck('numberOfChannels').max().value()\n      } else maxChannelsUpstream = 0\n      this._computeNumberOfChannels(maxChannelsUpstream)\n    }\n    var outBuffer = new AudioBuffer(this.computedNumberOfChannels, BLOCK_SIZE, this.context.sampleRate)\n\n    inBuffers.forEach(function(inBuffer)  {\n      var ch = new ChannelMixing(inBuffer.numberOfChannels, this$0.computedNumberOfChannels, this$0.node.channelInterpretation)\n      ch.process(inBuffer, outBuffer)\n    })\n    return outBuffer\n  };\n\n  proto$0._computeNumberOfChannels = function(maxChannelsUpstream) {\n    var countMode = this.node.channelCountMode,\n      channelCount = this.node.channelCount\n    maxChannelsUpstream = maxChannelsUpstream || 1\n\n    if (countMode === 'max') {\n      this.computedNumberOfChannels = maxChannelsUpstream\n    } else if (countMode === 'clamped-max') {\n      this.computedNumberOfChannels = Math.min(maxChannelsUpstream, channelCount)\n    } else if (countMode === 'explicit')\n      this.computedNumberOfChannels = channelCount\n      // this shouldn't happen\n    else throw new Error('invalid channelCountMode')\n  };\n\nMIXIN$0(AudioInput.prototype,proto$0);proto$0=void 0;return AudioInput;})(AudioPort);\n\nvar AudioOutput = (function(super$0){\"use strict\";if(!PRS$0)MIXIN$0(AudioOutput, super$0);var proto$0={};\n\n  function AudioOutput(context, node, id) {\n    super$0.call(this, context, node, id)\n\n    // This caches the block fetched from the node.\n    this._cachedBlock = {\n      time: -1,\n      buffer: null\n    }\n\n    // This catches the number of channels of the audio going through this output\n    this._numberOfChannels = null\n\n    // Just for code clarity\n    Object.defineProperty(this, 'sinks', {\n      get: function() {\n        return this.connections\n      }\n    })\n  }if(super$0!==null)SP$0(AudioOutput,super$0);AudioOutput.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":AudioOutput,\"configurable\":true,\"writable\":true}});DP$0(AudioOutput,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  // Pulls the audio from the node only once, and copies it so that several\n  // nodes downstream can pull the same block.\n  proto$0._tick = function() {\n    if (this._cachedBlock.time < this.context.currentTime) {\n      var outBuffer = this.node._tick()\n      if (this._numberOfChannels !== outBuffer.numberOfChannels) {\n        this._numberOfChannels = outBuffer.numberOfChannels\n        this.emit('_numberOfChannels')\n      }\n      this._cachedBlock = {\n        time: this.context.currentTime,\n        buffer: outBuffer\n      }\n      return outBuffer\n    } else return this._cachedBlock.buffer\n  };\n\nMIXIN$0(AudioOutput.prototype,proto$0);proto$0=void 0;return AudioOutput;})(AudioPort);\n\nmodule.exports = {\n  AudioOutput: AudioOutput,\n  AudioInput: AudioInput\n}\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/ChannelMixing.js":"var BLOCK_SIZE = require('./constants').BLOCK_SIZE\n\nvar ChannelMixing = (function(){\"use strict\";var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var proto$0={};\n\n  function ChannelMixing(numberOfChannels, computedNumberOfChannels, channelInterpretation) {\n    this.numberOfChannels = numberOfChannels\n    this.computedNumberOfChannels = computedNumberOfChannels\n    this.channelInterpretation = channelInterpretation\n    if (this.numberOfChannels === this.computedNumberOfChannels) {\n      this._process = this.identityProcess\n    } else {\n      if (this.channelInterpretation === 'speakers') {\n        this._process = this['speakerMix' + this.numberOfChannels + this.computedNumberOfChannels]\n        if (!this._process) {\n          // well, this is ugly.\n          if (this.numberOfChannels < this.computedNumberOfChannels) {\n            this._process = this.discreteUpMix\n          } else {\n            this._process = this.discreteDownMix\n          }\n        }\n      } else {\n        if (this.numberOfChannels < this.computedNumberOfChannels) {\n          this._process = this.discreteUpMix\n        } else {\n          this._process = this.discreteDownMix\n        }\n      }\n    }\n  }DP$0(ChannelMixing,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0.identityProcess = function(inBuffer, outBuffer) {\n    var inData, outData\n    for (var ch = 0; ch < this.computedNumberOfChannels; ch++) {\n      inData = inBuffer.getChannelData(ch)\n      outData = outBuffer.getChannelData(ch)\n      for (var i = 0; i < BLOCK_SIZE; i++)\n        outData[i] += inData[i]\n    }\n  };\n\n  proto$0.discreteUpMix = function(inBuffer, outBuffer) {\n    var chDataIn, chDataOut\n    for (var ch = 0; ch < this.numberOfChannels; ch++) {\n      chDataIn = inBuffer.getChannelData(ch)\n      chDataOut = outBuffer.getChannelData(ch)\n      for (var i = 0; i < BLOCK_SIZE; i++) chDataOut[i] += chDataIn[i]\n    }\n  };\n\n  proto$0.discreteDownMix = function(inBuffer, outBuffer) {\n    var chDataIn, chDataOut\n    for (var ch = 0; ch < this.computedNumberOfChannels; ch++) {\n      chDataIn = inBuffer.getChannelData(ch)\n      chDataOut = outBuffer.getChannelData(ch)\n      for (var i = 0; i < BLOCK_SIZE; i++) {\n        chDataOut[i] += chDataIn[i]\n      }\n    }\n  };\n\n  proto$0.speakerMix12 = function(inBuffer, outBuffer) {\n    var inData = inBuffer.getChannelData(0)\n    var dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += inData[i]\n      dataOutR[i] += inData[i]\n    }\n  };\n\n  proto$0.speakerMix14 = function(inBuffer, outBuffer) {\n    var inData = inBuffer.getChannelData(0)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += inData[i]\n      dataOutR[i] += inData[i]\n    }\n  };\n\n  proto$0.speakerMix16 = function(inBuffer, outBuffer) {\n    var inData = inBuffer.getChannelData(0)\n      , dataOutC = outBuffer.getChannelData(2)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutC[i] += inData[i]\n    }\n  };\n\n  proto$0.speakerMix24 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i]\n      dataOutR[i] += dataR[i]\n    }\n  };\n\n  proto$0.speakerMix26 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i]\n      dataOutR[i] += dataR[i]\n    }\n  };\n\n  proto$0.speakerMix46 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataSL = inBuffer.getChannelData(2)\n      , dataSR = inBuffer.getChannelData(3)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n      , dataOutSL = outBuffer.getChannelData(4)\n      , dataOutSR = outBuffer.getChannelData(5)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i]\n      dataOutR[i] += dataR[i]\n      dataOutSL[i] += dataSL[i]\n      dataOutSR[i] += dataSR[i]\n    }\n  };\n\n  proto$0.speakerMix21 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataOut = outBuffer.getChannelData(0)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOut[i] += 0.5 * (dataL[i] + dataR[i])\n    }\n  };\n\n  proto$0.speakerMix41 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataSL = inBuffer.getChannelData(2)\n      , dataSR = inBuffer.getChannelData(3)\n      , dataOut = outBuffer.getChannelData(0)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOut[i] += 0.25 * (dataL[i] + dataR[i] + dataSL[i] + dataSR[i])\n    }\n  };\n\n  proto$0.speakerMix42 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataSL = inBuffer.getChannelData(2)\n      , dataSR = inBuffer.getChannelData(3)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += 0.5 * (dataL[i] + dataSL[i])\n      dataOutR[i] += 0.5 * (dataR[i] + dataSR[i])\n    }\n  };\n\n  proto$0.speakerMix61 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataC = inBuffer.getChannelData(2)\n      , dataLFE = inBuffer.getChannelData(3)\n      , dataSL = inBuffer.getChannelData(4)\n      , dataSR = inBuffer.getChannelData(5)\n      , dataOut = outBuffer.getChannelData(0)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOut[i] += 0.7071 * (dataL[i] + dataR[i]) + dataC[i] + 0.5 * (dataSL[i] + dataSR[i])\n    }\n  };\n\n  proto$0.speakerMix62 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataC = inBuffer.getChannelData(2)\n      , dataLFE = inBuffer.getChannelData(3)\n      , dataSL = inBuffer.getChannelData(4)\n      , dataSR = inBuffer.getChannelData(5)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i] + 0.7071 * (dataC[i] + dataSL[i])\n      dataOutR[i] += dataR[i] + 0.7071 * (dataC[i] + dataSR[i])\n    }\n  };\n\n  proto$0.speakerMix64 = function(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataC = inBuffer.getChannelData(2)\n      , dataLFE = inBuffer.getChannelData(3)\n      , dataSL = inBuffer.getChannelData(4)\n      , dataSR = inBuffer.getChannelData(5)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n      , dataOutSL = outBuffer.getChannelData(2)\n      , dataOutSR = outBuffer.getChannelData(3)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i] + 0.7071 * dataC[i]\n      dataOutR[i] += dataR[i] + 0.7071 * dataC[i]\n      dataOutSL[i] += dataSL[i]\n      dataOutSR[i] += dataSR[i]\n    }\n  };\n\n  proto$0.process = function(inBuffer, outBuffer) {\n    this._process(inBuffer, outBuffer)\n    return outBuffer\n  };\nMIXIN$0(ChannelMixing.prototype,proto$0);proto$0=void 0;return ChannelMixing;})();\n\nmodule.exports = ChannelMixing\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/AudioBufferSourceNode.js":"var constants = require('./constants')\n  , AudioNode = require('./AudioNode')\n  , AudioParam = require('./AudioParam')\n  , AudioBuffer = require('./AudioBuffer')\n  , readOnlyAttr = require('./utils').readOnlyAttr\n\n\nvar AudioBufferSourceNode = (function(super$0){\"use strict\";var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;if(!PRS$0)MIXIN$0(AudioBufferSourceNode, super$0);var proto$0={};\n\n  function AudioBufferSourceNode(context) {\n    super$0.call(this, context, 0, 1, undefined, 'max', 'speakers')\n\n    this.buffer = null\n    this.loop = false\n    this.loopStart = 0\n    this.loopEnd = 0\n\n    readOnlyAttr(this, 'playbackRate', new AudioParam(this.context, 1, 'a'))\n\n    this._dsp = this._dspZeros\n  }if(super$0!==null)SP$0(AudioBufferSourceNode,super$0);AudioBufferSourceNode.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":AudioBufferSourceNode,\"configurable\":true,\"writable\":true}});DP$0(AudioBufferSourceNode,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0.start = function(when, offset, duration) {var this$0 = this;\n    this._schedule('start', when, function()  {\n      if (!this$0.buffer) throw new Error('invalid buffer')\n\n      // Subsequent calls to `start` have no effect\n      this$0.start = function() {}\n\n      // keeps track of the current position in the buffer\n      var blockSize = constants.BLOCK_SIZE,\n        sampleRate = this$0.context.sampleRate,\n        cursor, cursorEnd, cursorNext, missingFrames, outBuffer\n\n      var reinitPlayback = function()  {\n        cursor = (offset ? offset : this$0.loopStart) * sampleRate\n        if (duration) cursorEnd = cursor + duration * sampleRate\n        else if (this$0.loopEnd) cursorEnd = this$0.loopEnd * sampleRate\n        else cursorEnd = this$0.buffer.length\n        cursorNext = cursor\n      }\n      reinitPlayback()\n\n      this$0._dsp = function() {\n        cursorNext = cursor + blockSize\n        // If there's enough data left to be read in the buffer, just read it,\n        // otherwise we need to handle things a bit differently\n        if (cursorNext < cursorEnd) {\n          outBuffer = this.buffer.slice(cursor, cursorNext)\n          cursor = cursorNext\n          return outBuffer\n        } else {\n          outBuffer = new AudioBuffer(this.buffer.numberOfChannels, blockSize, sampleRate)\n          outBuffer.set(this.buffer.slice(cursor, cursorNext))\n          // If looping, we must reinitialize our cursor variables.\n          // If not looping, we free the node\n          if (this.loop) {\n            missingFrames = cursorNext - cursorEnd\n            reinitPlayback()\n            cursorNext = cursor + missingFrames\n            outBuffer.set(this.buffer.slice(cursor, cursorNext), outBuffer.length - missingFrames)\n          } else {\n            if (this.onended) {\n              this._schedule('onended', this.context.currentTime + (cursorNext - cursorEnd) / sampleRate, this.onended)\n            }\n            this._schedule('kill', this.context.currentTime + (cursorNext - cursorEnd) / sampleRate, this._kill.bind(this))\n          }\n          cursor = cursorNext\n          return outBuffer\n        }\n      }\n\n    })\n  };\n\n  proto$0.stop = function(when) {var this$0 = this;\n    this._schedule('stop', when, function()  {\n      this$0._dsp = this$0._dspZeros\n    })\n  };\n\n  proto$0.onended = function() {};\n\n  proto$0._tick = function() {\n    super$0.prototype._tick.call(this, arguments)\n    return this._dsp()\n  };\n\n  proto$0._dsp = function() {};\n\n  proto$0._dspZeros = function() {\n    return new AudioBuffer(1, constants.BLOCK_SIZE, this.context.sampleRate)\n  };\n\nMIXIN$0(AudioBufferSourceNode.prototype,proto$0);proto$0=void 0;return AudioBufferSourceNode;})(AudioNode);\n\nmodule.exports = AudioBufferSourceNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/AudioParam.js":"var DspObject = require('./DspObject')\n  , AudioInput = require('./audioports').AudioInput\n  , AudioBuffer = require('./AudioBuffer')\n  , BLOCK_SIZE = require('./constants').BLOCK_SIZE\n\nvar AudioParam = (function(super$0){\"use strict\";var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;if(!PRS$0)MIXIN$0(AudioParam, super$0);var proto$0={};\n\n  function AudioParam(context, defaultValue, rate) {\n    super$0.call(this, context)\n\n    if (typeof defaultValue !== 'number')\n      throw new Error('defaultValue must be a number')\n\n    rate = rate || 'k'\n    if (rate !== 'a' && rate !== 'k')\n      throw new Error('invalid rate, must be a or k')\n    this._rate = rate\n\n    Object.defineProperty(this, 'defaultValue', {\n      value: defaultValue,\n      writable: false\n    })\n\n    this._instrinsicValue = defaultValue\n    Object.defineProperty(this, 'value', {\n      get: function() {\n        return this._instrinsicValue\n      },\n      set: function(newVal) {\n        this._instrinsicValue = newVal\n        this._toConstant()\n        this._scheduled = []\n      }\n    })\n\n    this._toConstant()\n\n    // Using AudioNodes as inputs for AudioParam :\n    // we have to set same channel attributes as for AudioNodes,\n    // so the input knows how to do the mixing\n    this.channelInterpretation = 'discrete'\n    this.channelCount = 1\n    this.channelCountMode = 'explicit'\n    this._input = new AudioInput(this.context, this, 0)\n  }if(super$0!==null)SP$0(AudioParam,super$0);AudioParam.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":AudioParam,\"configurable\":true,\"writable\":true}});DP$0(AudioParam,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0.setValueAtTime = function(value, startTime) {var this$0 = this;\n    this._schedule('SetValue', startTime, function()  {\n      this$0._instrinsicValue = value\n      this$0._nextEvent()\n    })\n  };\n\n  proto$0.linearRampToValueAtTime = function(value, endTime) {var this$0 = this;\n    this._schedule('LinearRampToValue', endTime, function()  {\n      this$0._instrinsicValue = value\n      this$0._nextEvent()\n    }, [value])\n    this._nextEvent()\n  };\n\n  proto$0.exponentialRampToValueAtTime = function(value, endTime) {var this$0 = this;\n    if (this._instrinsicValue <= 0 || value <= 0)\n      throw new Error('cannot create exponential ramp with value <= 0')\n    this._schedule('ExponentialRampToValue', endTime, function()  {\n      this$0._instrinsicValue = value\n      this$0._nextEvent()\n    }, [value])\n    this._nextEvent()\n  };\n\n  proto$0.setTargetAtTime = function(target, startTime, timeConstant) {var this$0 = this;\n    this._schedule('SetTarget', startTime, function()  {\n      this$0['_to_' + this$0._rate + 'Rate_setTarget'](target, timeConstant, function()  {\n        this$0._instrinsicValue = target\n        this$0._nextEvent()\n      })\n    })\n  };\n\n  proto$0.setValueCurveAtTime = function(values, startTime, duration) {var this$0 = this;\n    this._schedule('SetValueCurve', startTime, function()  {\n      this$0['_to_' + this$0._rate + 'Rate_SetValueCurve'](values, startTime, duration, function()  {\n        this$0._instrinsicValue = values[values.length - 1]\n        this$0._nextEvent()\n      })\n    })\n  };\n\n  proto$0._nextEvent = function() {\n    var event = this._scheduled[0]\n    if (event) {\n      if (event.type === 'LinearRampToValue')\n        this['_to_' + this._rate + 'Rate_linearRamp'](event.args[0], event.time)\n      else if (event.type === 'ExponentialRampToValue')\n        this['_to_' + this._rate + 'Rate_exponentialRamp'](event.args[0], event.time)\n      else this._toConstant()\n    } else this._toConstant()\n  };\n\n  proto$0._tick = function() {\n    super$0.prototype._tick.call(this)\n    var buffer = new AudioBuffer(1, BLOCK_SIZE, this.context.sampleRate)\n    this._dsp(buffer.getChannelData(0))\n    return buffer\n  };\n\n  // This method calculates intrinsic values\n  proto$0._dsp = function() {};\n\n  // -------------------- DSP methods -------------------- //\n  proto$0._toConstant = function() {\n    var value = this._instrinsicValue,\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = value\n    }\n  };\n\n  proto$0._to_aRate_linearRamp = function(target, endTime) {\n    var U0 = this._instrinsicValue,\n      Un = U0,\n      startTime = this.context.currentTime,\n      step = (target - U0) / (endTime - startTime) * 1 / this.context.sampleRate,\n      next = this._arithmeticSeries(U0, step),\n      clip = step > 0 ? Math.min : Math.max,\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        array[i] = clip(Un, target)\n        Un = next()\n      }\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  };\n\n  proto$0._to_kRate_linearRamp = function(target, endTime) {\n    var U0 = this._instrinsicValue,\n      Un = U0,\n      startTime = this.context.currentTime,\n      step = (target - U0) / (endTime - startTime) * BLOCK_SIZE / this.context.sampleRate,\n      next = this._arithmeticSeries(U0, step),\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = Un\n      Un = next()\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  };\n\n  proto$0._to_aRate_exponentialRamp = function(target, timeEnd) {\n    var timeStart = this.context.currentTime,\n      U0 = this._instrinsicValue,\n      Un = U0,\n      ratio = Math.pow(target / U0, 1 / (this.context.sampleRate * (timeEnd - timeStart))),\n      next = this._geometricSeries(U0, ratio),\n      clip = ratio > 1 ? Math.min : Math.max,\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        array[i] = clip(target, Un)\n        Un = next()\n      }\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  };\n\n  proto$0._to_kRate_exponentialRamp = function(target, timeEnd) {\n    var timeStart = this.context.currentTime,\n      U0 = this._instrinsicValue,\n      Un = U0,\n      ratio = Math.pow(target / U0, BLOCK_SIZE / (this.context.sampleRate * (timeEnd - timeStart))),\n      next = this._geometricSeries(U0, ratio),\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = Un\n      Un = next()\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  };\n\n  proto$0._to_aRate_setTarget = function(target, Tc, onended) {\n    var timeStart = this.context.currentTime,\n      U0 = (this._instrinsicValue - target),\n      Un = target + U0,\n      ratio = Math.exp(-(1 / this.context.sampleRate) / Tc),\n      next = this._geometricSeries(U0, ratio),\n      clip = U0 > 0 ? Math.max : Math.min,\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        array[i] = clip(Un, target)\n        Un = target + next()\n      }\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n      if (array[BLOCK_SIZE - 1] === target) onended()\n    }\n  };\n\n  proto$0._to_kRate_setTarget = function(target, Tc, onended) {\n    var timeStart = this.context.currentTime,\n      U0 = this._instrinsicValue - target,\n      Un = target + U0,\n      ratio = Math.exp(-(BLOCK_SIZE / this.context.sampleRate) / Tc),\n      next = this._geometricSeries(U0, ratio),\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = Un\n      Un = target + next()\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  };\n\n  proto$0._to_aRate_SetValueCurve = function(values, startTime, duration, onended) {\n    var valuesLength = values.length,\n      coeff = valuesLength / duration,\n      Ts = 1 / this.context.sampleRate,\n      i, t\n\n    this._dsp = function(array) {\n      t = this.context.currentTime\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        array[i] = values[Math.min(Math.round(coeff * (t - startTime)), valuesLength - 1)]\n        t += Ts\n      }\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n      if (t - startTime >= duration) onended()\n    }\n  };\n\n  proto$0._to_kRate_SetValueCurve = function(values, startTime, duration, onended) {\n    var valuesLength = values.length,\n      coeff = valuesLength / duration,\n      Ts = 1 / this.context.sampleRate,\n      i, val\n\n    this._dsp = function(array) {\n      val = values[Math.min(Math.round(coeff * (this.context.currentTime - startTime)), valuesLength - 1)]\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = val\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  };\n\n  proto$0._geometricSeries = function(U0, ratio) {\n    var Un = U0\n    return function() {\n      return Un *= ratio\n    }\n  };\n\n  proto$0._arithmeticSeries = function(U0, step) {\n    var Un = U0\n    return function() {\n      return Un += step\n    }\n  };\n\n  proto$0.cancelScheduledValues = function(startTime) {\n    throw new Error('implement me')\n  };\n\nMIXIN$0(AudioParam.prototype,proto$0);proto$0=void 0;return AudioParam;})(DspObject);\n\nmodule.exports = AudioParam\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/GainNode.js":"var AudioNode = require('./AudioNode')\n  , AudioParam = require('./AudioParam')\n  , AudioBuffer = require('./AudioBuffer')\n  , BLOCK_SIZE = require('./constants').BLOCK_SIZE\n  , readOnlyAttr = require('./utils').readOnlyAttr\n\nvar GainNode = (function(super$0){\"use strict\";var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;if(!PRS$0)MIXIN$0(GainNode, super$0);var proto$0={};\n\n  function GainNode(context) {\n    super$0.call(this, context, 1, 1, undefined, 'max', 'speakers')\n    readOnlyAttr(this, 'gain', new AudioParam(this.context, 1, 'a'))\n  }if(super$0!==null)SP$0(GainNode,super$0);GainNode.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":GainNode,\"configurable\":true,\"writable\":true}});DP$0(GainNode,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  proto$0._tick = function() {\n    var outBuff, inBuff, gainArray, i, ch, inChArray, outChArray\n    super$0.prototype._tick.call(this, arguments)\n    inBuff = this._inputs[0]._tick()\n    gainArray = this.gain._tick().getChannelData(0)\n    outBuff = new AudioBuffer(inBuff.numberOfChannels, BLOCK_SIZE, this.context.sampleRate)\n    for (ch = 0; ch < inBuff.numberOfChannels; ch++) {\n      inChArray = inBuff.getChannelData(ch)\n      outChArray = outBuff.getChannelData(ch)\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        outChArray[i] = inChArray[i] * gainArray[i]\n      }\n    }\n    return outBuff\n  };\n\nMIXIN$0(GainNode.prototype,proto$0);proto$0=void 0;return GainNode;})(AudioNode);\n\nmodule.exports = GainNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/build/ScriptProcessorNode.js":"var PRS$0 = (function(o,t){o[\"__proto__\"]={\"a\":t};return o[\"a\"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var _ = require('underscore')\n  , BLOCK_SIZE = require('./constants').BLOCK_SIZE\n  , AudioNode = require('./AudioNode')\n  , AudioBuffer = require('./AudioBuffer')\n  , readOnlyAttr = require('./utils').readOnlyAttr\n\n\nvar ScriptProcessorNode = (function(super$0){\"use strict\";var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o[\"__proto__\"]=p;}else {DP$0(o,\"__proto__\",{\"value\":p,\"configurable\":true,\"enumerable\":false,\"writable\":true});}return o};var OC$0 = Object.create;if(!PRS$0)MIXIN$0(ScriptProcessorNode, super$0);var proto$0={};\n\n  function ScriptProcessorNode(context, bufferSize, numberOfInputChannels, numberOfOutputChannels) {\n    if (!_.contains([256, 512, 1024, 2048, 4096, 8192, 16384], bufferSize))\n      throw new Error('invalid bufferSize')\n    super$0.call(this, context, 1, 1, numberOfInputChannels, 'explicit', 'speakers')\n\n    this.numberOfOutputChannels = numberOfOutputChannels\n    readOnlyAttr(this, 'bufferSize', bufferSize)\n  }if(super$0!==null)SP$0(ScriptProcessorNode,super$0);ScriptProcessorNode.prototype = OC$0(super$0!==null?super$0.prototype:null,{\"constructor\":{\"value\":ScriptProcessorNode,\"configurable\":true,\"writable\":true}, onaudioprocess: {\"set\": $onaudioprocess_set$0, \"configurable\":true,\"enumerable\":true}});DP$0(ScriptProcessorNode,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n  function $onaudioprocess_set$0(onaudioprocess) {\n\n    var inputBuffer = new AudioBuffer(this.channelCount, 0, this.context.sampleRate)\n      , outputBuffer = new AudioBuffer(this.numberOfOutputChannels, 0, this.context.sampleRate)\n\n    this._tick = function() {\n      AudioNode.prototype._tick.apply(this, arguments)\n\n      // Pull some data and add it to `inputBuffer`\n      inputBuffer = inputBuffer.concat(this._inputs[0]._tick())\n\n      // When enough data in `inputBuffer`, we run `onaudioprocess`\n      if (inputBuffer.length === this.bufferSize) {\n        var audioProcEvent = this._processingEvent(inputBuffer)\n        onaudioprocess(audioProcEvent)\n        inputBuffer = new AudioBuffer(this.channelCount, 0, this.context.sampleRate)\n        outputBuffer = outputBuffer.concat(audioProcEvent.outputBuffer)\n      } else if (inputBuffer.length >= this.bufferSize) throw new Error('this shouldnt happen')\n\n      // When data has been processed, we return it\n      if (outputBuffer.length >= BLOCK_SIZE) {\n        var returnedBuffer = outputBuffer.slice(0, BLOCK_SIZE)\n        outputBuffer = outputBuffer.slice(BLOCK_SIZE)\n        return returnedBuffer\n      } else return new AudioBuffer(this.numberOfOutputChannels, BLOCK_SIZE, this.context.sampleRate)\n    }\n  }\n\n  proto$0._processingEvent = function(inBuffer) {\n    return new AudioProcessingEvent(\n      this.context.currentTime,\n      inBuffer,\n      new AudioBuffer(this.numberOfOutputChannels, this.bufferSize, this.context.sampleRate)\n    )\n  };\n\n  proto$0._tick = function() {\n    super$0.prototype._tick.call(this, arguments)\n    return new AudioBuffer(this.numberOfOutputChannels, BLOCK_SIZE, this.context.sampleRate)\n  };\n\nMIXIN$0(ScriptProcessorNode.prototype,proto$0);proto$0=void 0;return ScriptProcessorNode;})(AudioNode);\n\n\nvar AudioProcessingEvent = (function(){\"use strict\";\n\n  function AudioProcessingEvent(playbackTime, inputBuffer, outputBuffer) {\n    this.playbackTime = playbackTime\n    this.inputBuffer = inputBuffer\n    this.outputBuffer = outputBuffer\n  }DP$0(AudioProcessingEvent,\"prototype\",{\"configurable\":false,\"enumerable\":false,\"writable\":false});\n\n;return AudioProcessingEvent;})();\n\nmodule.exports = ScriptProcessorNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/gulpfile.js":"var gulp = require('gulp')\n  , gutil = require('gulp-util')\n  , contribs = require('gulp-contribs')\n  , es6transpiler = require('gulp-es6-transpiler')\n\ngulp.task('default', function () {\n    return gulp.src('lib/*.js')\n      .pipe(es6transpiler({ disallowDuplicated: false }))\n      .on('error', gutil.log)\n      .pipe(gulp.dest('build'))\n})\n\ngulp.task('contribs', function () {\n    gulp.src('README.md')\n      .pipe(contribs('Contributors\\n-------------', 'Changelog\\n-----------'))\n      .pipe(gulp.dest('./'))\n})\n\n\ngulp.task('watch', function() {\n    gulp.watch('./lib/*.js', ['default'])\n})\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/AudioBuffer.js":"var _ = require('underscore')\n\nclass AudioBuffer {\n\n  constructor(numberOfChannels, length, sampleRate) {\n    var ch\n    this._data = []\n    // Just a hack to be able to create a partially initialized AudioBuffer\n    if (arguments.length) {\n      for (ch = 0; ch < numberOfChannels; ch++)\n        this._data.push(new Float32Array(length))\n      this._defineAttrs(numberOfChannels, length, sampleRate)\n    }\n  }\n\n  getChannelData(channel) {\n    if (channel >= this.numberOfChannels) throw new Error('invalid channel')\n    return this._data[channel]\n  }\n\n  slice() {\n    var sliceArgs = _.toArray(arguments)\n    var array = this._data.map(function(chArray) {\n        return chArray.subarray.apply(chArray, sliceArgs)\n      })\n    return AudioBuffer.fromArray(array, this.sampleRate)\n  }\n\n  concat(other) {\n    if (other.sampleRate !== this.sampleRate)\n      throw new Error('the 2 AudioBuffers don\\'t have the same sampleRate')\n    if (other.numberOfChannels !== this.numberOfChannels)\n      throw new Error('the 2 AudioBuffers don\\'t have the same numberOfChannels')\n    var newLength = other.length + this.length,\n      newChArray, newArray = this._data.map(function(chArray, ch) {\n        newChArray = new Float32Array(newLength)\n        newChArray.set(chArray)\n        newChArray.set(other._data[ch], chArray.length)\n        return newChArray\n      })\n    return AudioBuffer.fromArray(newArray, this.sampleRate)\n  }\n\n  set(other, offset) {\n    if (other.sampleRate !== this.sampleRate)\n      throw new Error('the 2 AudioBuffers don\\'t have the same sampleRate')\n    if (other.numberOfChannels !== this.numberOfChannels)\n      throw new Error('the 2 AudioBuffers don\\'t have the same numberOfChannels')\n    this._data.forEach(function(chArray, ch) {\n      chArray.set(other.getChannelData(ch), offset)\n    })\n  }\n\n  _defineAttrs(numberOfChannels, length, sampleRate) {\n    if (!(sampleRate > 0)) throw new Error('invalid sample rate : ' + sampleRate)\n    Object.defineProperty(this, 'sampleRate', {\n      value: sampleRate,\n      writable: false\n    })\n    if (!(length >= 0)) throw new Error('invalid length : ' + length)\n    Object.defineProperty(this, 'length', {\n      value: length,\n      writable: false\n    })\n    Object.defineProperty(this, 'duration', {\n      value: length / sampleRate,\n      writable: false\n    })\n    if (!(numberOfChannels > 0)) throw new Error('invalid numberOfChannels : ' + numberOfChannels)\n    Object.defineProperty(this, 'numberOfChannels', {\n      value: numberOfChannels,\n      writable: false\n    })\n  }\n\n  static filledWithVal(val, numberOfChannels, length, sampleRate) {\n    var audioBuffer = new AudioBuffer(numberOfChannels, length, sampleRate),\n      chData, ch, i\n    for (ch = 0; ch < numberOfChannels; ch++) {\n      chData = audioBuffer._data[ch]\n      for (i = 0; i < length; i++) chData[i] = val\n    }\n    return audioBuffer\n  }\n\n  static fromArray(array, sampleRate) {\n    var audioBuffer = new AudioBuffer()\n    audioBuffer._defineAttrs(array.length, array[0].length, sampleRate)\n    array.forEach(function(chArray) {\n      if (!(chArray instanceof Float32Array))\n        chArray = new Float32Array(chArray)\n      audioBuffer._data.push(chArray)\n    })\n    return audioBuffer\n  }\n\n}\n\nmodule.exports = AudioBuffer\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/AudioBufferSourceNode.js":"var constants = require('./constants')\n  , AudioNode = require('./AudioNode')\n  , AudioParam = require('./AudioParam')\n  , AudioBuffer = require('./AudioBuffer')\n  , readOnlyAttr = require('./utils').readOnlyAttr\n\n\nclass AudioBufferSourceNode extends AudioNode {\n\n  constructor(context) {\n    super(context, 0, 1, undefined, 'max', 'speakers')\n\n    this.buffer = null\n    this.loop = false\n    this.loopStart = 0\n    this.loopEnd = 0\n\n    readOnlyAttr(this, 'playbackRate', new AudioParam(this.context, 1, 'a'))\n\n    this._dsp = this._dspZeros\n  }\n\n  start(when, offset, duration) {\n    this._schedule('start', when, () => {\n      if (!this.buffer) throw new Error('invalid buffer')\n\n      // Subsequent calls to `start` have no effect\n      this.start = function() {}\n\n      // keeps track of the current position in the buffer\n      var blockSize = constants.BLOCK_SIZE,\n        sampleRate = this.context.sampleRate,\n        cursor, cursorEnd, cursorNext, missingFrames, outBuffer\n\n      var reinitPlayback = () => {\n        cursor = (offset ? offset : this.loopStart) * sampleRate\n        if (duration) cursorEnd = cursor + duration * sampleRate\n        else if (this.loopEnd) cursorEnd = this.loopEnd * sampleRate\n        else cursorEnd = this.buffer.length\n        cursorNext = cursor\n      }\n      reinitPlayback()\n\n      this._dsp = function() {\n        cursorNext = cursor + blockSize\n        // If there's enough data left to be read in the buffer, just read it,\n        // otherwise we need to handle things a bit differently\n        if (cursorNext < cursorEnd) {\n          outBuffer = this.buffer.slice(cursor, cursorNext)\n          cursor = cursorNext\n          return outBuffer\n        } else {\n          outBuffer = new AudioBuffer(this.buffer.numberOfChannels, blockSize, sampleRate)\n          outBuffer.set(this.buffer.slice(cursor, cursorNext))\n          // If looping, we must reinitialize our cursor variables.\n          // If not looping, we free the node\n          if (this.loop) {\n            missingFrames = cursorNext - cursorEnd\n            reinitPlayback()\n            cursorNext = cursor + missingFrames\n            outBuffer.set(this.buffer.slice(cursor, cursorNext), outBuffer.length - missingFrames)\n          } else {\n            if (this.onended) {\n              this._schedule('onended', this.context.currentTime + (cursorNext - cursorEnd) / sampleRate, this.onended)\n            }\n            this._schedule('kill', this.context.currentTime + (cursorNext - cursorEnd) / sampleRate, this._kill.bind(this))\n          }\n          cursor = cursorNext\n          return outBuffer\n        }\n      }\n\n    })\n  }\n\n  stop(when) {\n    this._schedule('stop', when, () => {\n      this._dsp = this._dspZeros\n    })\n  }\n\n  onended() {}\n\n  _tick() {\n    super._tick(arguments)\n    return this._dsp()\n  }\n\n  _dsp() {}\n\n  _dspZeros() {\n    return new AudioBuffer(1, constants.BLOCK_SIZE, this.context.sampleRate)\n  }\n\n}\n\nmodule.exports = AudioBufferSourceNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/constants.js":"module.exports.BLOCK_SIZE = 128","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/AudioNode.js":"var EventEmitter = require('events').EventEmitter\n  , async = require('async')\n  , utils = require('./utils')\n  , readOnlyAttr = utils.readOnlyAttr\n  , DspObject = require('./DspObject')\n  , AudioInput = require('./audioports').AudioInput\n  , AudioOutput = require('./audioports').AudioOutput\n\nvar ChannelCountMode = ['max', 'clamped-max', 'explicit'],\n  ChannelInterpretation = ['speakers', 'discrete']\n\nclass AudioNode extends DspObject {\n\n  constructor(context, numberOfInputs, numberOfOutputs, channelCount, channelCountMode, channelInterpretation) {\n\n    super(context)\n\n    readOnlyAttr(this, 'context', context)\n    readOnlyAttr(this, 'numberOfInputs', numberOfInputs)\n    readOnlyAttr(this, 'numberOfOutputs', numberOfOutputs)\n\n    channelCount = channelCount || 2\n    Object.defineProperty(this, 'channelCount', {\n      get: function() {\n        return channelCount\n      },\n      set: function(val) {\n        if (val < 1) throw new Error('Invalid number of channels')\n        channelCount = val\n      },\n      configurable: true\n    })\n\n    var channelCountMode = channelCountMode\n    Object.defineProperty(this, 'channelCountMode', {\n      get: function() {\n        return channelCountMode\n      },\n      set: function(val) {\n        if (ChannelCountMode.indexOf(val) === -1)\n          throw new Error('Unvalid value for channelCountMode : ' + val)\n        channelCountMode = val\n      },\n      configurable: true\n    })\n\n    var channelInterpretation = channelInterpretation\n    Object.defineProperty(this, 'channelInterpretation', {\n      get: function() {\n        return channelInterpretation\n      },\n      set: function(val) {\n        if (ChannelInterpretation.indexOf(val) === -1)\n          throw new Error('Unvalid value for channelInterpretation : ' + val)\n        channelInterpretation = val\n      },\n      configurable: true\n    })\n\n    // Initialize audio ports\n    var i\n    this._inputs = []\n    this._outputs = []\n    for (i = 0; i < this.numberOfInputs; i++)\n      this._inputs.push(new AudioInput(context, this, i))\n    for (i = 0; i < this.numberOfOutputs; i++)\n      this._outputs.push(new AudioOutput(context, this, i))\n\n  }\n\n  connect(destination, output = 0, input = 0) {\n    if (output >= this.numberOfOutputs)\n      throw new Error('output out of bounds ' + output)\n    if (input >= destination.numberOfInputs)\n      throw new Error('input out of bounds ' + input)\n    this._outputs[output].connect(destination._inputs[input])\n  }\n\n  disconnect(output = 0) {\n    if (output >= this.numberOfOutputs)\n      throw new Error('output out of bounds ' + output)\n    var audioOut = this._outputs[output]\n    audioOut.sinks.slice(0).forEach(function(sink) {\n      audioOut.disconnect(sink)\n    })\n  }\n\n  // Disconnects all ports and remove all events listeners\n  _kill() {\n    this._inputs.forEach(function(input) {\n      input._kill()\n    })\n    this._outputs.forEach(function(output) {\n      output._kill()\n    })\n    this.removeAllListeners()\n    this._tick = function() {\n      throw new Error('this node has been killed')\n    }\n  }\n\n}\n\nmodule.exports = AudioNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/utils.js":"var AudioBuffer = require('./AudioBuffer')\n  , AV = require('av')\n  , mp3 = require('mp3')\n  , flac = require('flac')\n  , alac = require('alac')\n  , aac = require('aac')\n\n\n// Simple helper to make defining a read-only attribute less verbose\nmodule.exports.readOnlyAttr = function(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    value: value,\n    writable: false\n  })\n}\n\n// Helper to decode a buffer of encoded audio data.\n// Guesses the format, and decodes to an AudioBuffer accordingly.\nmodule.exports.decodeAudioData = function(buffer, done) {\n  var asset = AV.Asset.fromBuffer(buffer)\n\n  asset.on('error', function(err) {\n    done(err)\n  })\n\n  asset.decodeToBuffer(function(decoded) {\n    var deinterleaved = []\n      , numberOfChannels = asset.format.channelsPerFrame\n      , length = Math.floor(decoded.length / numberOfChannels)\n      , ch, chArray, i\n\n    for (ch = 0; ch < numberOfChannels; ch++)\n      deinterleaved.push(new Float32Array(length))\n\n    for (ch = 0; ch < numberOfChannels; ch++) {\n      chArray = deinterleaved[ch]\n      for (i = 0; i < length; i++)\n        chArray[i] = decoded[ch + i * numberOfChannels]\n    }\n\n    done(null, AudioBuffer.fromArray(deinterleaved, asset.format.sampleRate))\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/DspObject.js":"var _ = require('underscore')\n  , events = require('events')\n\nclass DspObject extends events.EventEmitter {\n\n  constructor(context) {\n    super()\n    this.context = context\n    this._scheduled = []\n  }\n\n  _tick() {\n    this._frame++\n    var event = this._scheduled.shift()\n      , eventsSameTime, eventsToExecute = []\n      , previousTime\n    \n    // Gather all events that need to be executed at this tick\n    while (event && event.time <= this.context.currentTime) {\n      previousTime = event.time\n      eventsSameTime = []\n      // Gather all the events with same time\n      while (event && event.time === previousTime) {\n        // Add the event only if there isn't already events with same type\n        if (eventsSameTime.every(function(other) {\n          return event.type !== other.type\n        })) eventsSameTime.push(event)\n        event = this._scheduled.shift()\n      }\n      eventsSameTime.forEach(function(event) {\n        eventsToExecute.push(event)\n      })\n    }\n    if (event) this._scheduled.unshift(event)\n    \n    // And execute\n    eventsToExecute.reverse().forEach(function(event) {\n      event.func && event.func()\n    })\n  }\n\n  _schedule(type, time, func, args) {\n    var event = {\n        time: time,\n        func: func,\n        type: type\n      },\n      ind = _.sortedIndex(this._scheduled, event, function(e) {\n        return e.time\n      })\n    if (args) event.args = args\n    this._scheduled.splice(ind, 0, event)\n  }\n\n  _unscheduleTypes(types) {\n    this._scheduled = _.reject(this._scheduled, function(event) {\n      return _.contains(types, event.type)\n    })\n  }\n\n}\n\nmodule.exports = DspObject\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/audioports.js":"var _ = require('underscore')\n  , async = require('async')\n  , events = require('events')\n  , utils = require('./utils')\n  , AudioBuffer = require('./AudioBuffer')\n  , BLOCK_SIZE = require('./constants').BLOCK_SIZE\n  , ChannelMixing = require('./ChannelMixing')\n\n\nclass AudioPort extends events.EventEmitter {\n\n  constructor(context, node, id) {\n    super()\n    this.connections = []\n    this.node = node\n    this.id = id\n    this.context = context\n  }\n\n  // Generic function for connecting the calling AudioPort\n  // with `otherPort`. Returns true if a connection was indeed established\n  connect(otherPort) {\n    if (this.connections.indexOf(otherPort) !== -1) return false\n    this.connections.push(otherPort)\n    otherPort.connect(this)\n    this.emit('connection', otherPort)\n    return true\n  }\n\n  // Generic function for disconnecting the calling AudioPort\n  // from `otherPort`. Returns true if a disconnection was indeed made\n  disconnect(otherPort) {\n    var connInd = this.connections.indexOf(otherPort)\n    if (connInd === -1) return false\n    this.connections.splice(connInd, 1)\n    otherPort.disconnect(this)\n    this.emit('disconnection', otherPort)\n    return true\n  }\n\n  // Called when a node is killed. Removes connections, and event listeners.\n  _kill() {\n    this.connections.slice(0).forEach((port) => {\n      this.disconnect(port)\n    })\n    this.removeAllListeners()\n  }\n\n}\n\nclass AudioInput extends AudioPort {\n\n  constructor(context, node, id) {\n    super(context, node, id)\n\n    // `computedNumberOfChannels` is scheduled to be recalculated everytime a connection\n    // or disconnection happens.\n    this.computedNumberOfChannels = null\n    this.on('connected', () => {\n      this.computedNumberOfChannels = null\n    })\n    this.on('disconnected', () => {\n      this.computedNumberOfChannels = null\n    })\n\n    // Just for code clarity\n    Object.defineProperty(this, 'sources', {\n      get: function() {\n        return this.connections\n      }\n    })\n  }\n\n  connect(source) {\n    // When the number of channels of the source changes, we trigger\n    // computation of `computedNumberOfChannels`\n    source.on('_numberOfChannels', () => {\n      this.computedNumberOfChannels = null\n    })\n    //AudioPort.prototype.connect.call(this, source)\n    super.connect(source)\n  }\n\n  disconnect(source) {\n    source.removeAllListeners('_numberOfChannels')\n    //AudioPort.prototype.disconnect.call(this, source)\n    super.disconnect(source)\n  }\n\n  _tick() {\n    var i, ch, inNumChannels, inBuffers = this.sources.map(function(source) {\n      return source._tick()\n    })\n\n    if (this.computedNumberOfChannels === null) {\n      var maxChannelsUpstream\n      if (this.sources.length) {\n        maxChannelsUpstream = _.chain(inBuffers).pluck('numberOfChannels').max().value()\n      } else maxChannelsUpstream = 0\n      this._computeNumberOfChannels(maxChannelsUpstream)\n    }\n    var outBuffer = new AudioBuffer(this.computedNumberOfChannels, BLOCK_SIZE, this.context.sampleRate)\n\n    inBuffers.forEach((inBuffer) => {\n      var ch = new ChannelMixing(inBuffer.numberOfChannels, this.computedNumberOfChannels, this.node.channelInterpretation)\n      ch.process(inBuffer, outBuffer)\n    })\n    return outBuffer\n  }\n\n  _computeNumberOfChannels(maxChannelsUpstream) {\n    var countMode = this.node.channelCountMode,\n      channelCount = this.node.channelCount\n    maxChannelsUpstream = maxChannelsUpstream || 1\n\n    if (countMode === 'max') {\n      this.computedNumberOfChannels = maxChannelsUpstream\n    } else if (countMode === 'clamped-max') {\n      this.computedNumberOfChannels = Math.min(maxChannelsUpstream, channelCount)\n    } else if (countMode === 'explicit')\n      this.computedNumberOfChannels = channelCount\n      // this shouldn't happen\n    else throw new Error('invalid channelCountMode')\n  }\n\n}\n\nclass AudioOutput extends AudioPort {\n\n  constructor(context, node, id) {\n    super(context, node, id)\n\n    // This caches the block fetched from the node.\n    this._cachedBlock = {\n      time: -1,\n      buffer: null\n    }\n\n    // This catches the number of channels of the audio going through this output\n    this._numberOfChannels = null\n\n    // Just for code clarity\n    Object.defineProperty(this, 'sinks', {\n      get: function() {\n        return this.connections\n      }\n    })\n  }\n\n  // Pulls the audio from the node only once, and copies it so that several\n  // nodes downstream can pull the same block.\n  _tick() {\n    if (this._cachedBlock.time < this.context.currentTime) {\n      var outBuffer = this.node._tick()\n      if (this._numberOfChannels !== outBuffer.numberOfChannels) {\n        this._numberOfChannels = outBuffer.numberOfChannels\n        this.emit('_numberOfChannels')\n      }\n      this._cachedBlock = {\n        time: this.context.currentTime,\n        buffer: outBuffer\n      }\n      return outBuffer\n    } else return this._cachedBlock.buffer\n  }\n\n}\n\nmodule.exports = {\n  AudioOutput: AudioOutput,\n  AudioInput: AudioInput\n}\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/ChannelMixing.js":"var BLOCK_SIZE = require('./constants').BLOCK_SIZE\n\nclass ChannelMixing {\n\n  constructor(numberOfChannels, computedNumberOfChannels, channelInterpretation) {\n    this.numberOfChannels = numberOfChannels\n    this.computedNumberOfChannels = computedNumberOfChannels\n    this.channelInterpretation = channelInterpretation\n    if (this.numberOfChannels === this.computedNumberOfChannels) {\n      this._process = this.identityProcess\n    } else {\n      if (this.channelInterpretation === 'speakers') {\n        this._process = this['speakerMix' + this.numberOfChannels + this.computedNumberOfChannels]\n        if (!this._process) {\n          // well, this is ugly.\n          if (this.numberOfChannels < this.computedNumberOfChannels) {\n            this._process = this.discreteUpMix\n          } else {\n            this._process = this.discreteDownMix\n          }\n        }\n      } else {\n        if (this.numberOfChannels < this.computedNumberOfChannels) {\n          this._process = this.discreteUpMix\n        } else {\n          this._process = this.discreteDownMix\n        }\n      }\n    }\n  }\n\n  identityProcess(inBuffer, outBuffer) {\n    var inData, outData\n    for (var ch = 0; ch < this.computedNumberOfChannels; ch++) {\n      inData = inBuffer.getChannelData(ch)\n      outData = outBuffer.getChannelData(ch)\n      for (var i = 0; i < BLOCK_SIZE; i++)\n        outData[i] += inData[i]\n    }\n  }\n\n  discreteUpMix(inBuffer, outBuffer) {\n    var chDataIn, chDataOut\n    for (var ch = 0; ch < this.numberOfChannels; ch++) {\n      chDataIn = inBuffer.getChannelData(ch)\n      chDataOut = outBuffer.getChannelData(ch)\n      for (var i = 0; i < BLOCK_SIZE; i++) chDataOut[i] += chDataIn[i]\n    }\n  }\n\n  discreteDownMix(inBuffer, outBuffer) {\n    var chDataIn, chDataOut\n    for (var ch = 0; ch < this.computedNumberOfChannels; ch++) {\n      chDataIn = inBuffer.getChannelData(ch)\n      chDataOut = outBuffer.getChannelData(ch)\n      for (var i = 0; i < BLOCK_SIZE; i++) {\n        chDataOut[i] += chDataIn[i]\n      }\n    }\n  }\n\n  speakerMix12(inBuffer, outBuffer) {\n    var inData = inBuffer.getChannelData(0)\n    var dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += inData[i]\n      dataOutR[i] += inData[i]\n    }\n  }\n\n  speakerMix14(inBuffer, outBuffer) {\n    var inData = inBuffer.getChannelData(0)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += inData[i]\n      dataOutR[i] += inData[i]\n    }\n  }\n\n  speakerMix16(inBuffer, outBuffer) {\n    var inData = inBuffer.getChannelData(0)\n      , dataOutC = outBuffer.getChannelData(2)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutC[i] += inData[i]\n    }\n  }\n\n  speakerMix24(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i]\n      dataOutR[i] += dataR[i]\n    }\n  }\n\n  speakerMix26(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i]\n      dataOutR[i] += dataR[i]\n    }\n  }\n\n  speakerMix46(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataSL = inBuffer.getChannelData(2)\n      , dataSR = inBuffer.getChannelData(3)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n      , dataOutSL = outBuffer.getChannelData(4)\n      , dataOutSR = outBuffer.getChannelData(5)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i]\n      dataOutR[i] += dataR[i]\n      dataOutSL[i] += dataSL[i]\n      dataOutSR[i] += dataSR[i]\n    }\n  }\n\n  speakerMix21(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataOut = outBuffer.getChannelData(0)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOut[i] += 0.5 * (dataL[i] + dataR[i])\n    }\n  }\n\n  speakerMix41(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataSL = inBuffer.getChannelData(2)\n      , dataSR = inBuffer.getChannelData(3)\n      , dataOut = outBuffer.getChannelData(0)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOut[i] += 0.25 * (dataL[i] + dataR[i] + dataSL[i] + dataSR[i])\n    }\n  }\n\n  speakerMix42(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataSL = inBuffer.getChannelData(2)\n      , dataSR = inBuffer.getChannelData(3)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += 0.5 * (dataL[i] + dataSL[i])\n      dataOutR[i] += 0.5 * (dataR[i] + dataSR[i])\n    }\n  }\n\n  speakerMix61(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataC = inBuffer.getChannelData(2)\n      , dataLFE = inBuffer.getChannelData(3)\n      , dataSL = inBuffer.getChannelData(4)\n      , dataSR = inBuffer.getChannelData(5)\n      , dataOut = outBuffer.getChannelData(0)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOut[i] += 0.7071 * (dataL[i] + dataR[i]) + dataC[i] + 0.5 * (dataSL[i] + dataSR[i])\n    }\n  }\n\n  speakerMix62(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataC = inBuffer.getChannelData(2)\n      , dataLFE = inBuffer.getChannelData(3)\n      , dataSL = inBuffer.getChannelData(4)\n      , dataSR = inBuffer.getChannelData(5)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i] + 0.7071 * (dataC[i] + dataSL[i])\n      dataOutR[i] += dataR[i] + 0.7071 * (dataC[i] + dataSR[i])\n    }\n  }\n\n  speakerMix64(inBuffer, outBuffer) {\n    var dataL = inBuffer.getChannelData(0)\n      , dataR = inBuffer.getChannelData(1)\n      , dataC = inBuffer.getChannelData(2)\n      , dataLFE = inBuffer.getChannelData(3)\n      , dataSL = inBuffer.getChannelData(4)\n      , dataSR = inBuffer.getChannelData(5)\n      , dataOutL = outBuffer.getChannelData(0)\n      , dataOutR = outBuffer.getChannelData(1)\n      , dataOutSL = outBuffer.getChannelData(2)\n      , dataOutSR = outBuffer.getChannelData(3)\n    for (var i = 0; i < BLOCK_SIZE; i++) {\n      dataOutL[i] += dataL[i] + 0.7071 * dataC[i]\n      dataOutR[i] += dataR[i] + 0.7071 * dataC[i]\n      dataOutSL[i] += dataSL[i]\n      dataOutSR[i] += dataSR[i]\n    }\n  }\n\n  process(inBuffer, outBuffer) {\n    this._process(inBuffer, outBuffer)\n    return outBuffer\n  }\n}\n\nmodule.exports = ChannelMixing\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/AudioParam.js":"var DspObject = require('./DspObject')\n  , AudioInput = require('./audioports').AudioInput\n  , AudioBuffer = require('./AudioBuffer')\n  , BLOCK_SIZE = require('./constants').BLOCK_SIZE\n\nclass AudioParam extends DspObject {\n\n  constructor(context, defaultValue, rate) {\n    super(context)\n\n    if (typeof defaultValue !== 'number')\n      throw new Error('defaultValue must be a number')\n\n    rate = rate || 'k'\n    if (rate !== 'a' && rate !== 'k')\n      throw new Error('invalid rate, must be a or k')\n    this._rate = rate\n\n    Object.defineProperty(this, 'defaultValue', {\n      value: defaultValue,\n      writable: false\n    })\n\n    this._instrinsicValue = defaultValue\n    Object.defineProperty(this, 'value', {\n      get: function() {\n        return this._instrinsicValue\n      },\n      set: function(newVal) {\n        this._instrinsicValue = newVal\n        this._toConstant()\n        this._scheduled = []\n      }\n    })\n\n    this._toConstant()\n\n    // Using AudioNodes as inputs for AudioParam :\n    // we have to set same channel attributes as for AudioNodes,\n    // so the input knows how to do the mixing\n    this.channelInterpretation = 'discrete'\n    this.channelCount = 1\n    this.channelCountMode = 'explicit'\n    this._input = new AudioInput(this.context, this, 0)\n  }\n\n  setValueAtTime(value, startTime) {\n    this._schedule('SetValue', startTime, () => {\n      this._instrinsicValue = value\n      this._nextEvent()\n    })\n  }\n\n  linearRampToValueAtTime(value, endTime) {\n    this._schedule('LinearRampToValue', endTime, () => {\n      this._instrinsicValue = value\n      this._nextEvent()\n    }, [value])\n    this._nextEvent()\n  }\n\n  exponentialRampToValueAtTime(value, endTime) {\n    if (this._instrinsicValue <= 0 || value <= 0)\n      throw new Error('cannot create exponential ramp with value <= 0')\n    this._schedule('ExponentialRampToValue', endTime, () => {\n      this._instrinsicValue = value\n      this._nextEvent()\n    }, [value])\n    this._nextEvent()\n  }\n\n  setTargetAtTime(target, startTime, timeConstant) {\n    this._schedule('SetTarget', startTime, () => {\n      this['_to_' + this._rate + 'Rate_setTarget'](target, timeConstant, () => {\n        this._instrinsicValue = target\n        this._nextEvent()\n      })\n    })\n  }\n\n  setValueCurveAtTime(values, startTime, duration) {\n    this._schedule('SetValueCurve', startTime, () => {\n      this['_to_' + this._rate + 'Rate_SetValueCurve'](values, startTime, duration, () => {\n        this._instrinsicValue = values[values.length - 1]\n        this._nextEvent()\n      })\n    })\n  }\n\n  _nextEvent() {\n    var event = this._scheduled[0]\n    if (event) {\n      if (event.type === 'LinearRampToValue')\n        this['_to_' + this._rate + 'Rate_linearRamp'](event.args[0], event.time)\n      else if (event.type === 'ExponentialRampToValue')\n        this['_to_' + this._rate + 'Rate_exponentialRamp'](event.args[0], event.time)\n      else this._toConstant()\n    } else this._toConstant()\n  }\n\n  _tick() {\n    super._tick()\n    var buffer = new AudioBuffer(1, BLOCK_SIZE, this.context.sampleRate)\n    this._dsp(buffer.getChannelData(0))\n    return buffer\n  }\n\n  // This method calculates intrinsic values\n  _dsp() {}\n\n  // -------------------- DSP methods -------------------- //\n  _toConstant() {\n    var value = this._instrinsicValue,\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = value\n    }\n  }\n\n  _to_aRate_linearRamp(target, endTime) {\n    var U0 = this._instrinsicValue,\n      Un = U0,\n      startTime = this.context.currentTime,\n      step = (target - U0) / (endTime - startTime) * 1 / this.context.sampleRate,\n      next = this._arithmeticSeries(U0, step),\n      clip = step > 0 ? Math.min : Math.max,\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        array[i] = clip(Un, target)\n        Un = next()\n      }\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  }\n\n  _to_kRate_linearRamp(target, endTime) {\n    var U0 = this._instrinsicValue,\n      Un = U0,\n      startTime = this.context.currentTime,\n      step = (target - U0) / (endTime - startTime) * BLOCK_SIZE / this.context.sampleRate,\n      next = this._arithmeticSeries(U0, step),\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = Un\n      Un = next()\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  }\n\n  _to_aRate_exponentialRamp(target, timeEnd) {\n    var timeStart = this.context.currentTime,\n      U0 = this._instrinsicValue,\n      Un = U0,\n      ratio = Math.pow(target / U0, 1 / (this.context.sampleRate * (timeEnd - timeStart))),\n      next = this._geometricSeries(U0, ratio),\n      clip = ratio > 1 ? Math.min : Math.max,\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        array[i] = clip(target, Un)\n        Un = next()\n      }\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  }\n\n  _to_kRate_exponentialRamp(target, timeEnd) {\n    var timeStart = this.context.currentTime,\n      U0 = this._instrinsicValue,\n      Un = U0,\n      ratio = Math.pow(target / U0, BLOCK_SIZE / (this.context.sampleRate * (timeEnd - timeStart))),\n      next = this._geometricSeries(U0, ratio),\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = Un\n      Un = next()\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  }\n\n  _to_aRate_setTarget(target, Tc, onended) {\n    var timeStart = this.context.currentTime,\n      U0 = (this._instrinsicValue - target),\n      Un = target + U0,\n      ratio = Math.exp(-(1 / this.context.sampleRate) / Tc),\n      next = this._geometricSeries(U0, ratio),\n      clip = U0 > 0 ? Math.max : Math.min,\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        array[i] = clip(Un, target)\n        Un = target + next()\n      }\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n      if (array[BLOCK_SIZE - 1] === target) onended()\n    }\n  }\n\n  _to_kRate_setTarget(target, Tc, onended) {\n    var timeStart = this.context.currentTime,\n      U0 = this._instrinsicValue - target,\n      Un = target + U0,\n      ratio = Math.exp(-(BLOCK_SIZE / this.context.sampleRate) / Tc),\n      next = this._geometricSeries(U0, ratio),\n      i\n\n    this._dsp = function(array) {\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = Un\n      Un = target + next()\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  }\n\n  _to_aRate_SetValueCurve(values, startTime, duration, onended) {\n    var valuesLength = values.length,\n      coeff = valuesLength / duration,\n      Ts = 1 / this.context.sampleRate,\n      i, t\n\n    this._dsp = function(array) {\n      t = this.context.currentTime\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        array[i] = values[Math.min(Math.round(coeff * (t - startTime)), valuesLength - 1)]\n        t += Ts\n      }\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n      if (t - startTime >= duration) onended()\n    }\n  }\n\n  _to_kRate_SetValueCurve(values, startTime, duration, onended) {\n    var valuesLength = values.length,\n      coeff = valuesLength / duration,\n      Ts = 1 / this.context.sampleRate,\n      i, val\n\n    this._dsp = function(array) {\n      val = values[Math.min(Math.round(coeff * (this.context.currentTime - startTime)), valuesLength - 1)]\n      for (i = 0; i < BLOCK_SIZE; i++) array[i] = val\n      this._instrinsicValue = array[BLOCK_SIZE - 1]\n    }\n  }\n\n  _geometricSeries(U0, ratio) {\n    var Un = U0\n    return function() {\n      return Un *= ratio\n    }\n  }\n\n  _arithmeticSeries(U0, step) {\n    var Un = U0\n    return function() {\n      return Un += step\n    }\n  }\n\n  cancelScheduledValues(startTime) {\n    throw new Error('implement me')\n  }\n\n}\n\nmodule.exports = AudioParam\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/AudioContext.js":"var _ = require('underscore')\n  , events = require('events')\n  , async = require('async')\n  , pcmUtils = require('pcm-boilerplate')\n  , utils = require('./utils')\n  , constants = require('./constants')\n  , BLOCK_SIZE = constants.BLOCK_SIZE\n  , AudioBuffer = require('./AudioBuffer')\n  , AudioDestinationNode = require('./AudioDestinationNode')\n  , AudioBufferSourceNode = require('./AudioBufferSourceNode')\n  , GainNode = require('./GainNode')\n  , ScriptProcessorNode = require('./ScriptProcessorNode')\n\n\nclass AudioContext extends events.EventEmitter {\n\n  constructor(opts) {\n    var outBuff\n\n    /*Object.defineProperty(this, 'currentTime', {\n    writable: false,\n    get: function() {}\n  })*/\n\n    Object.defineProperty(this, 'destination', {\n      writable: false,\n      value: new AudioDestinationNode(this)\n    })\n    //this.destination = new AudioDestinationNode(this)\n\n    /*Object.defineProperty(this, 'sampleRate', {\n    writable: false,\n    value: {} // TODO\n  })\n\n  Object.defineProperty(this, 'listener', {\n    writable: false,\n    value: {} // TODO\n  })*/\n    this.currentTime = 0\n    this.sampleRate = 44100\n    this.numberOfChannels = 2\n    this.bitDepth = 16\n\n    this.format = {\n      numberOfChannels: 2,\n      bitDepth: 16,\n      sampleRate: this.sampleRate\n    }\n\n    opts = opts || {}\n    if (opts.bufferSize) this.format.bufferSize = opts.bufferSize\n    if (opts.numBuffers) this.format.numBuffers = opts.numBuffers\n\n    this.outStream = null\n    this._encoder = pcmUtils.BufferEncoder(this.format)\n    this._frame = 0\n    this._playing = true\n    this._audioOutLoopRunning = false\n\n    // When a new connection is established, start to pull audio\n    this.destination._inputs[0].on('connection', () => {\n      if (this._audioOutLoopRunning) return\n      if (!this.outStream) throw new Error('you need to set outStream to send the audio somewhere')\n      this._audioOutLoopRunning = true\n      async.whilst(\n        () => {\n          return this._playing\n        },\n        (next) => {\n          outBuff = this.destination._tick()\n          // If there is space in the output stream's buffers, we write,\n          // otherwise we wait for 'drain'\n          this._frame += BLOCK_SIZE\n          this.currentTime = this._frame * 1 / this.sampleRate\n          // TODO setImmediate here is for cases where the outStream won't get\n          // full and we end up with call stack max size reached.\n          // But is it optimal?\n          if (this.outStream.write(this._encoder(outBuff._data)))\n            setImmediate(next)\n          else this.outStream.once('drain', next)\n        },\n        (err) => {\n          this._audioOutLoopRunning = false\n          if (err) return this.emit('error', err)\n        }\n      )\n    })\n  }\n\n  createBuffer(numberOfChannels, length, sampleRate) {\n    return new AudioBuffer(numberOfChannels, length, sampleRate)\n  }\n\n  decodeAudioData(audioData, successCallback, errorCallback) {\n    utils.decodeAudioData(audioData, function(err, audioBuffer) {\n      if (err) errorCallback(err)\n      else successCallback(audioBuffer)\n    })\n  }\n\n  createBufferSource() {\n    return new AudioBufferSourceNode(this)\n  }\n\n  createGain() {\n    return new GainNode(this)\n  }\n\n  createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels) {\n    return new ScriptProcessorNode(this, bufferSize, numberOfInputChannels, numberOfOutputChannels)\n  }\n\n  /*\n{\n\n    readonly attribute AudioDestinationNode destination\n    readonly attribute float sampleRate\n    readonly attribute double currentTime\n    readonly attribute AudioListener listener\n\n    // AudioNode creation\n    MediaElementAudioSourceNode createMediaElementSource(HTMLMediaElement mediaElement)\n\n    MediaStreamAudioSourceNode createMediaStreamSource(MediaStream mediaStream)\n    MediaStreamAudioDestinationNode createMediaStreamDestination()\n\n    AnalyserNode createAnalyser()\n    DelayNode createDelay(optional double maxDelayTime = 1.0)\n    BiquadFilterNode createBiquadFilter()\n    WaveShaperNode createWaveShaper()\n    PannerNode createPanner()\n    ConvolverNode createConvolver()\n\n    ChannelSplitterNode createChannelSplitter(optional unsigned long numberOfOutputs = 6)\n    ChannelMergerNode createChannelMerger(optional unsigned long numberOfInputs = 6)\n\n    DynamicsCompressorNode createDynamicsCompressor()\n\n    OscillatorNode createOscillator()\n    PeriodicWave createPeriodicWave(Float32Array real, Float32Array imag)\n\n}\n  */\n\n  _kill() {\n    this._playing = false\n    if (this.outStream) {\n      if (this.outStream.close) {\n        this.outStream.close()\n      } else {\n        this.outStream.end()\n      }\n    }\n  }\n\n  collectNodes(node, allNodes) {\n    allNodes = allNodes || []\n    node = node || this.destination\n    _.chain(node._inputs)\n      .pluck('sources')\n      .reduce(function(all, sources) {\n        return all.concat(sources)\n      }, [])\n      .pluck('node').value()\n      .forEach((upstreamNode) => {\n        if (!_.contains(allNodes, upstreamNode)) {\n          allNodes.push(upstreamNode)\n          this.collectNodes(upstreamNode, allNodes)\n        }\n      })\n    return allNodes\n  }\n\n}\n\nmodule.exports = AudioContext\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/AudioDestinationNode.js":"var AudioNode = require('./AudioNode')\n  , readOnlyAttr = require('./utils').readOnlyAttr\n\n\nclass AudioDestinationNode extends AudioNode {\n\n  constructor(context) {\n    super(context, 1, 0, 2, 'explicit', 'speakers')\n\n    readOnlyAttr(this, 'maxChannelCount', 2)\n  }\n\n  // This only pulls the data from the nodes upstream\n  _tick() {\n    return this._inputs[0]._tick()\n  }\n\n}\n\n\nmodule.exports = AudioDestinationNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/GainNode.js":"var AudioNode = require('./AudioNode')\n  , AudioParam = require('./AudioParam')\n  , AudioBuffer = require('./AudioBuffer')\n  , BLOCK_SIZE = require('./constants').BLOCK_SIZE\n  , readOnlyAttr = require('./utils').readOnlyAttr\n\nclass GainNode extends AudioNode {\n\n  constructor(context) {\n    super(context, 1, 1, undefined, 'max', 'speakers')\n    readOnlyAttr(this, 'gain', new AudioParam(this.context, 1, 'a'))\n  }\n\n  _tick() {\n    var outBuff, inBuff, gainArray, i, ch, inChArray, outChArray\n    super._tick(arguments)\n    inBuff = this._inputs[0]._tick()\n    gainArray = this.gain._tick().getChannelData(0)\n    outBuff = new AudioBuffer(inBuff.numberOfChannels, BLOCK_SIZE, this.context.sampleRate)\n    for (ch = 0; ch < inBuff.numberOfChannels; ch++) {\n      inChArray = inBuff.getChannelData(ch)\n      outChArray = outBuff.getChannelData(ch)\n      for (i = 0; i < BLOCK_SIZE; i++) {\n        outChArray[i] = inChArray[i] * gainArray[i]\n      }\n    }\n    return outBuff\n  }\n\n}\n\nmodule.exports = GainNode\n","/home/travis/build/npmtest/node-npmtest-web-audio-api/node_modules/web-audio-api/lib/ScriptProcessorNode.js":"var _ = require('underscore')\n  , BLOCK_SIZE = require('./constants').BLOCK_SIZE\n  , AudioNode = require('./AudioNode')\n  , AudioBuffer = require('./AudioBuffer')\n  , readOnlyAttr = require('./utils').readOnlyAttr\n\n\nclass ScriptProcessorNode extends AudioNode {\n\n  constructor(context, bufferSize, numberOfInputChannels, numberOfOutputChannels) {\n    if (!_.contains([256, 512, 1024, 2048, 4096, 8192, 16384], bufferSize))\n      throw new Error('invalid bufferSize')\n    super(context, 1, 1, numberOfInputChannels, 'explicit', 'speakers')\n\n    this.numberOfOutputChannels = numberOfOutputChannels\n    readOnlyAttr(this, 'bufferSize', bufferSize)\n  }\n\n  set onaudioprocess(onaudioprocess) {\n\n    var inputBuffer = new AudioBuffer(this.channelCount, 0, this.context.sampleRate)\n      , outputBuffer = new AudioBuffer(this.numberOfOutputChannels, 0, this.context.sampleRate)\n\n    this._tick = function() {\n      AudioNode.prototype._tick.apply(this, arguments)\n\n      // Pull some data and add it to `inputBuffer`\n      inputBuffer = inputBuffer.concat(this._inputs[0]._tick())\n\n      // When enough data in `inputBuffer`, we run `onaudioprocess`\n      if (inputBuffer.length === this.bufferSize) {\n        var audioProcEvent = this._processingEvent(inputBuffer)\n        onaudioprocess(audioProcEvent)\n        inputBuffer = new AudioBuffer(this.channelCount, 0, this.context.sampleRate)\n        outputBuffer = outputBuffer.concat(audioProcEvent.outputBuffer)\n      } else if (inputBuffer.length >= this.bufferSize) throw new Error('this shouldnt happen')\n\n      // When data has been processed, we return it\n      if (outputBuffer.length >= BLOCK_SIZE) {\n        var returnedBuffer = outputBuffer.slice(0, BLOCK_SIZE)\n        outputBuffer = outputBuffer.slice(BLOCK_SIZE)\n        return returnedBuffer\n      } else return new AudioBuffer(this.numberOfOutputChannels, BLOCK_SIZE, this.context.sampleRate)\n    }\n  }\n\n  _processingEvent(inBuffer) {\n    return new AudioProcessingEvent(\n      this.context.currentTime,\n      inBuffer,\n      new AudioBuffer(this.numberOfOutputChannels, this.bufferSize, this.context.sampleRate)\n    )\n  }\n\n  _tick() {\n    super._tick(arguments)\n    return new AudioBuffer(this.numberOfOutputChannels, BLOCK_SIZE, this.context.sampleRate)\n  }\n\n}\n\n\nclass AudioProcessingEvent {\n\n  constructor(playbackTime, inputBuffer, outputBuffer) {\n    this.playbackTime = playbackTime\n    this.inputBuffer = inputBuffer\n    this.outputBuffer = outputBuffer\n  }\n\n}\n\nmodule.exports = ScriptProcessorNode\n"}